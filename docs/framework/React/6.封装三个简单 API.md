# 封装三个简单 API

## Portal

`react` 提供了 `createPortal` 的 api，可以把组件渲染到某个 dom 下。

```tsx
import { createPortal } from "react-dom";

function App() {
  const content = (
    <div className="btn">
      <button>按钮</button>
    </div>
  );

  return createPortal(content, document.body);
}

export default App;
```

我们也可以把它封装成 Portal 组件来用。

:::code-group

```tsx [Portal.tsx]
import React, {
  forwardRef,
  useEffect,
  useImperativeHandle,
  useMemo,
} from "react";
import { createPortal } from "react-dom";

// 定义 Portal 组件的 props 接口
export interface PortalProps {
  attach?: HTMLElement | string; // 指定 Portal 挂载的目标元素
  children: React.ReactNode; // Portal 的子元素
}

// 获取挂载目标元素的辅助函数
export function getAttach(attach: PortalProps["attach"]) {
  if (typeof attach === "string") {
    return document.querySelector(attach);
  }

  if (typeof attach === "object" && attach instanceof window.HTMLElement) {
    return attach;
  }

  return document.body; // 默认挂载到 body
}

// 使用 forwardRef 创建 Portal 组件,以便可以传递 ref
const Portal = forwardRef((props: PortalProps, ref) => {
  const { attach = document.body, children } = props;

  // 创建一个 div 作为 Portal 的容器
  const container = useMemo(() => {
    const el = document.createElement("div");
    el.className = "portal-wrapper";
    return el;
  }, []);

  useEffect(() => {
    // 获取挂载目标元素
    const parentElement = getAttach(attach);
    // 将 Portal 容器添加到目标元素中
    parentElement?.appendChild?.(container);

    // 清理函数:组件卸载时移除 Portal 容器
    return () => {
      parentElement?.removeChild?.(container);
    };
  }, [container, attach]);

  // 将 container 组件 暴露给父组件
  useImperativeHandle(ref, () => container);

  // 使用 createPortal 将子元素渲染到 container 中
  return createPortal(children, container);
});

export default Portal;
```

```tsx [App.tsx]
import "./App.css";
import Portal from "./Portal";
import { useRef } from "react";

function App() {
  const containerRef = useRef<HTMLElement>(null);

  const content = (
    <div className="btn">
      <button>按钮</button>
    </div>
  );

  return (
    <Portal attach={document.head} ref={containerRef}>
      {content}
    </Portal>
  );
}

export default App;
```

:::

## MutateObserver

浏览器提供了 `MutationObserver` 的 api，可以监听 dom 的变化，包括子节点的变化、属性的变化。

用法:

```tsx
import { useEffect, useRef, useState } from "react";

export default function App() {
  // 状态用于控制显示的内容
  const [displayState, setDisplayState] = useState("初始状态");

  // 2秒后更改状态
  useEffect(() => {
    setTimeout(() => setDisplayState("更新状态"), 2000);
  }, []);

  // 创建对容器的引用
  const containerRef = useRef(null);

  // 设置 MutationObserver 来监视 DOM 变化
  useEffect(() => {
    const targetNode = containerRef.current!;

    // 定义回调函数,当观察到变化时被调用
    const callback = function (mutationsList: MutationRecord[]) {
      console.log("DOM 发生了变化:", mutationsList);
    };

    // 创建一个观察器实例并传入回调函数
    const observer = new MutationObserver(callback);

    // 开始观察目标节点
    observer.observe(targetNode, {
      attributes: true, // 观察属性变动
      childList: true, // 观察目标节点的子节点的增加和删除
      subtree: true, // 观察所有后代节点
      attributeFilter: ["class"],
    });

    // 组件卸载时停止观察
    return () => observer.disconnect();
  }, []);

  return (
    <div>
      <div id="container" ref={containerRef}>
        <div className={displayState}>
          {displayState === "初始状态" ? (
            <div>当前是初始状态</div>
          ) : (
            <div>
              <p>状态已更新</p>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}
```

`attributes` 是监听属性变化，`childList` 是监听 `children` 变化，`subtree` 是连带子节点的属性、`children` 变化也监听。

`attributeFilter` 可以指定监听哪些属性的变化。

### 封装 `useMutateObserver` 的 hook

```tsx
import { useEffect } from "react";

// 默认的 MutationObserver 配置选项
const defaultOptions: MutationObserverInit = {
  subtree: true, // 观察目标节点及其所有后代节点
  childList: true, // 观察子节点的添加或删除
  attributeFilter: ["style", "class"], // 只观察 style 和 class 属性的变化
};

export default function useMutateObserver(
  nodeOrList: HTMLElement | HTMLElement[], // 要观察的节点或节点列表
  callback: MutationCallback, // 当观察到变化时调用的回调函数
  options: MutationObserverInit = defaultOptions // 观察选项,默认使用 defaultOptions
) {
  useEffect(() => {
    // 如果没有提供节点,则直接返回
    if (!nodeOrList) {
      return;
    }

    let instance: MutationObserver;

    // 确保 nodeOrList 总是一个数组
    const nodeList = Array.isArray(nodeOrList) ? nodeOrList : [nodeOrList];

    // 检查浏览器是否支持 MutationObserver
    if ("MutationObserver" in window) {
      // 创建 MutationObserver 实例
      instance = new MutationObserver(callback);

      // 对每个节点启动观察
      nodeList.forEach((element) => {
        instance.observe(element, options);
      });
    }

    // 清理函数,在组件卸载或依赖项变化时调用
    return () => {
      // 取出并处理所有未处理的变更记录
      instance?.takeRecords();
      // 停止观察
      instance?.disconnect();
    };
  }, [options, nodeOrList]); // 依赖项:如果这些变化,效果会重新运行
}
```
